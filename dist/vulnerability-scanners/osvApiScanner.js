"use strict";
// core-engine/src/vulnerability-scanners/osvApiScanner.ts
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanOsvApi = scanOsvApi;
const https = __importStar(require("https"));
const OSV_API_URL = 'api.osv.dev';
const OSV_BATCH_QUERY_PATH = '/v1/querybatch';
async function makeOsvApiRequest(payload) {
    const postData = JSON.stringify(payload);
    const options = {
        hostname: OSV_API_URL,
        path: OSV_BATCH_QUERY_PATH,
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(postData),
        },
    };
    return new Promise((resolve) => {
        let responseBody = '';
        const req = https.request(options, (res) => {
            res.setEncoding('utf8');
            res.on('data', (chunk) => {
                responseBody += chunk;
            });
            res.on('end', () => {
                if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                        resolve(JSON.parse(responseBody));
                    }
                    catch (e) {
                        console.error('OSV API: Error parsing JSON response:', e);
                        resolve(null);
                    }
                }
                else {
                    console.error(`OSV API: Request failed with status code ${res.statusCode}: ${responseBody}`);
                    resolve(null);
                }
            });
        });
        req.on('error', (e) => {
            console.error('OSV API: Problem with request:', e);
            resolve(null);
        });
        req.write(postData);
        req.end();
    });
}
function mapOsvToInternalVulnerability(osvVuln, dep // The dependency that this OSV vuln applies to
) {
    let severity = 'INFO'; // Default
    let cvss = undefined;
    if (osvVuln.severity && osvVuln.severity.length > 0) {
        // Prioritize CVSS_V3, then look for score.
        // OSV severity score is a string like "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H" or just numeric score
        const cvssV3Severity = osvVuln.severity.find(s => s.type === 'CVSS_V3');
        if (cvssV3Severity) {
            // Try to parse out the numeric score and vector from the string
            const scoreMatch = cvssV3Severity.score.match(/(\d+\.\d+)/);
            const numericScore = scoreMatch ? parseFloat(scoreMatch[1]) : 0;
            cvss = {
                score: numericScore,
                vectorString: cvssV3Severity.score, // The full string is the vector
                version: '3.1' // Assuming 3.1 if type is CVSS_V3
            };
            if (numericScore >= 9.0)
                severity = 'CRITICAL';
            else if (numericScore >= 7.0)
                severity = 'HIGH';
            else if (numericScore >= 4.0)
                severity = 'MODERATE';
            else if (numericScore > 0.0)
                severity = 'LOW';
        }
        // Add more sophisticated severity parsing if needed
    }
    const affectedVersionsStrings = [];
    osvVuln.affected?.forEach(aff => {
        aff.versions?.forEach(v => affectedVersionsStrings.push(v));
        aff.ranges?.forEach(r => {
            r.events.forEach(e => {
                if (e.introduced === "0") { // Common way to say "all versions up to fixed"
                    if (e.fixed)
                        affectedVersionsStrings.push(`< ${e.fixed}`);
                    else if (e.limit)
                        affectedVersionsStrings.push(`< ${e.limit}`); // or <=
                    else
                        affectedVersionsStrings.push('(*)'); // All versions
                }
                else if (e.introduced) {
                    if (e.fixed)
                        affectedVersionsStrings.push(`>= ${e.introduced}, < ${e.fixed}`);
                    else if (e.limit)
                        affectedVersionsStrings.push(`>= ${e.introduced}, < ${e.limit}`);
                    else
                        affectedVersionsStrings.push(`>= ${e.introduced}`);
                }
            });
        });
    });
    // Try to find a fixed version from the ranges
    let fixedVersionFromRange;
    osvVuln.affected?.forEach(aff => {
        aff.ranges?.forEach(r => {
            const fixedEvent = r.events.find(e => e.fixed);
            if (fixedEvent && fixedEvent.fixed) {
                fixedVersionFromRange = fixedEvent.fixed;
            }
        });
    });
    return {
        id: osvVuln.id,
        packageName: dep.name,
        packageVersion: dep.version, // The specific version from the project
        title: osvVuln.summary || osvVuln.id,
        description: osvVuln.details || osvVuln.summary || 'No details provided.',
        severity,
        cvss,
        affectedVersions: affectedVersionsStrings.length > 0 ? affectedVersionsStrings : ['N/A'],
        fixedVersions: fixedVersionFromRange ? [fixedVersionFromRange] : undefined, // OSV may not always list a single "fixed" version easily
        references: osvVuln.references
            ? osvVuln.references.map((ref) => ({ url: ref.url, type: ref.type }))
            : [],
    };
}
/**
 * Scans a list of dependencies using the OSV.dev batch API.
 * @param dependencies The list of Dependency objects to scan.
 * @returns A Promise that resolves to an array of Vulnerability objects.
 */
async function scanOsvApi(dependencies) {
    if (!dependencies || dependencies.length === 0) {
        return [];
    }
    const queries = dependencies.map((dep) => ({
        version: dep.version,
        package: {
            name: dep.name,
            // Map internal ecosystem name to OSV ecosystem string
            ecosystem: dep.ecosystem === 'npm' || dep.ecosystem === 'yarn' ? 'npm' : dep.ecosystem,
        },
    }));
    const batchQueryPayload = { queries };
    const apiResult = await makeOsvApiRequest(batchQueryPayload);
    const foundVulnerabilities = [];
    if (apiResult && apiResult.results) {
        apiResult.results.forEach((queryResult, index) => {
            if (queryResult.vulns && queryResult.vulns.length > 0) {
                const originalDependency = dependencies[index]; // Relies on order being preserved
                queryResult.vulns.forEach((osvVuln) => {
                    foundVulnerabilities.push(mapOsvToInternalVulnerability(osvVuln, originalDependency));
                });
            }
        });
    }
    return foundVulnerabilities;
}
