"use strict";
// core-engine/src/vulnerability-scanners/npmAuditScanner.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.scanNpmAudit = scanNpmAudit;
const commandExecutor_1 = require("../utils/commandExecutor");
const fileSystem_1 = require("../utils/fileSystem");
/**
 * Scans Node.js project dependencies using `npm audit --json`.
 * This function assumes that the project uses npm and has a package-lock.json.
 *
 * @param projectPath The absolute path to the Node.js project directory.
 * @param dependencies (Optional) The list of dependencies. npm audit works on the lockfile directly.
 * @returns A Promise that resolves to an array of Vulnerability objects.
 */
async function scanNpmAudit(projectPath, dependencies) {
    const foundVulnerabilities = [];
    const packageLockPath = (0, fileSystem_1.joinPath)(projectPath, 'package-lock.json');
    if (!(await (0, fileSystem_1.pathExists)(packageLockPath))) {
        console.warn(`Skipping npm audit scan: package-lock.json not found in ${projectPath}`);
        return [];
    }
    // `npm audit --json` can be slow. Consider a timeout.
    // The command should be run in the project directory.
    const command = 'npm audit --json';
    const result = await (0, commandExecutor_1.executeCommand)(command, { cwd: projectPath });
    if (result.stderr && result.exitCode !== 0 && !result.stdout) { // npm audit might exit > 0 if vulns found
        // Check if stderr indicates a real execution error vs. just audit findings
        // Some npm versions output to stderr even on successful audit with findings
        if (!result.stderr.toLowerCase().includes('found vulnerabilities')) {
            console.error(`npm audit command execution failed for ${projectPath}: ${result.stderr}. Exit code: ${result.exitCode}`);
            // return []; // or throw
        }
    }
    if (!result.stdout) {
        console.warn(`npm audit produced no stdout for ${projectPath}. Stderr: ${result.stderr}`);
        return [];
    }
    try {
        const auditOutput = JSON.parse(result.stdout);
        // The structure of `npm audit --json` can vary slightly across npm versions.
        // We need to adapt to the common patterns.
        // Modern npm often has a top-level 'vulnerabilities' object.
        // Older versions might have 'advisories' and findings that refer to these advisories.
        if (auditOutput.vulnerabilities) {
            for (const vulnKey in auditOutput.vulnerabilities) {
                const auditVuln = auditOutput.vulnerabilities[vulnKey];
                // Extracting details can be complex due to 'via' array structure.
                // 'via' can contain strings (other packages) or objects with advisory details.
                let title = `Vulnerability in ${auditVuln.name}`;
                let description = `Package ${auditVuln.name} is affected by a vulnerability. Affected versions: ${auditVuln.range}.`;
                let advisoryUrl = '';
                let cveIdFromVia = undefined;
                let cvssFromAdvisory = undefined;
                let patchedVersionsFromAdvisory = undefined;
                let vulnerableVersionsFromAdvisory = auditVuln.range;
                // Try to get more details from the 'via' array if it contains advisory objects
                // or from a separate 'advisories' object if linked by ID.
                // This parsing logic needs to be robust.
                if (Array.isArray(auditVuln.via)) {
                    for (const viaEntry of auditVuln.via) {
                        if (typeof viaEntry === 'object' && viaEntry !== null && viaEntry.url && viaEntry.title) {
                            title = viaEntry.title || title;
                            advisoryUrl = viaEntry.url || advisoryUrl;
                            // Attempt to extract CVE from URL or title if possible (heuristic)
                            const cveMatch = advisoryUrl.match(/(CVE-\d{4}-\d{4,})/i) || title.match(/(CVE-\d{4}-\d{4,})/i);
                            if (cveMatch && cveMatch[1]) {
                                cveIdFromVia = cveMatch[1];
                            }
                            // If `npm audit` provides CVSS directly in advisory objects (some versions do)
                            if (auditOutput.advisories && viaEntry.source && auditOutput.advisories[viaEntry.source.toString()]) {
                                const advisory = auditOutput.advisories[viaEntry.source.toString()];
                                if (advisory.cvss && advisory.cvss.score) {
                                    cvssFromAdvisory = {
                                        score: advisory.cvss.score,
                                        vectorString: advisory.cvss.vectorString || 'N/A',
                                        version: '3.1' // Assuming CVSSv3, npm audit might not always specify
                                    };
                                }
                                patchedVersionsFromAdvisory = advisory.patched_versions;
                                vulnerableVersionsFromAdvisory = advisory.vulnerable_versions;
                            }
                            break; // Take details from the first rich advisory object in 'via'
                        }
                    }
                }
                const vulnId = cveIdFromVia || (auditVuln.via && auditVuln.via.find(v => typeof v === 'object' && v.source) ? `NPM-${auditVuln.via.find(v => typeof v === 'object' && v.source).source}` : `NPM-AUDIT-${auditVuln.name}-${auditVuln.range}`);
                const fixInfo = auditVuln.fixAvailable;
                const fixedVersions = [];
                if (typeof fixInfo === 'object' && fixInfo !== null && fixInfo.name === auditVuln.name && fixInfo.version) {
                    fixedVersions.push(fixInfo.version);
                }
                else if (patchedVersionsFromAdvisory && patchedVersionsFromAdvisory !== "<0.0.0") { // "<0.0.0" means no patch
                    fixedVersions.push(patchedVersionsFromAdvisory);
                }
                foundVulnerabilities.push({
                    id: vulnId,
                    packageName: auditVuln.name,
                    // npm audit output directly gives affected package, not the specific installed version easily without more parsing
                    // We need to map this back to the Dependency list or assume it applies to versions within `auditVuln.range`
                    // For now, let's use the range as affected.
                    packageVersion: auditVuln.range, // This is the vulnerable *range*, not the installed version.
                    title: title,
                    description: description,
                    severity: auditVuln.severity.toUpperCase(),
                    cvss: cvssFromAdvisory, // This may or may not be present or accurate
                    affectedVersions: vulnerableVersionsFromAdvisory ? [vulnerableVersionsFromAdvisory] : [auditVuln.range],
                    fixedVersions: fixedVersions.length > 0 ? fixedVersions : undefined,
                    references: advisoryUrl ? [{ url: advisoryUrl }] : [],
                });
            }
        }
        else if (auditOutput.advisories) {
            // Handle older npm audit format if necessary (where advisories are flat and actions/findings link to them)
            // This would require more complex logic to map findings back to dependencies.
            console.warn("`npm audit --json` output has 'advisories' top-level key. Parsing this format is more complex and not fully implemented in this example.");
        }
    }
    catch (error) {
        console.error(`Error parsing npm audit JSON output for ${projectPath}: ${error instanceof Error ? error.message : String(error)}. Raw output: ${result.stdout.substring(0, 500)}...`);
    }
    return foundVulnerabilities;
}
// Later, you might add scanYarnAudit if a project is identified as using Yarn + yarn.lock
// export async function scanYarnAudit(projectPath: string, dependencies: Dependency[]): Promise<Vulnerability[]> { /* ... */ }
