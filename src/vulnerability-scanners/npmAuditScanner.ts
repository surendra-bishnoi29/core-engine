// core-engine/src/vulnerability-scanners/npmAuditScanner.ts

import { Dependency, Vulnerability, CVSS } from '../shared/types';
import { executeCommand, CommandResult } from '../utils/commandExecutor';
import { pathExists, joinPath } from '../utils/fileSystem';

// Simplified interface for npm audit JSON output structure
// (The actual structure is more complex, refer to `npm help audit` for details)
interface NpmAuditAdvisory {
  id: number; // npm's internal ID
  module_name: string;
  vulnerable_versions: string;
  patched_versions: string;
  recommendation: string; // Often contains the version to upgrade to
  title: string;
  url: string; // Link to advisory
  severity: 'critical' | 'high' | 'moderate' | 'low' | 'info';
  cwe: string[];
  cvss: {
    score: number;
    vectorString: string;
  };
  // other fields...
}

interface NpmAuditFinding { // Represents a specific instance of a vulnerability
    version: string;
    paths: string[]; // Paths in the dependency tree
    dev: boolean;
    optional: boolean;
    bundled: boolean;
}

interface NpmAuditVulnerability { // A vulnerability that might affect multiple paths/versions
    name: string; // package name
    severity: 'critical' | 'high' | 'moderate' | 'low' | 'info';
    isDirect: boolean;
    via: Array<string | { source: number; name: string; dependency: string; title: string; url: string; severity: string; range: string; }>;
    effects: string[];
    range: string; // vulnerable versions range
    nodes: string[]; // paths in package-lock.json
    fixAvailable: boolean | { name: string; version: string; isSemVerMajor: boolean; };
    // The actual advisory details are usually linked by 'source' id in 'via'
}


interface NpmAuditOutput {
  auditReportVersion: number;
  vulnerabilities: {
    [packageName: string]: NpmAuditVulnerability; // Keyed by package name in some formats
  };
  // Or sometimes 'advisories' is a flat list keyed by advisory ID:
  advisories?: {
    [advisoryId: string]: NpmAuditAdvisory;
  };
  // Modern npm audit often has a structure like:
  // vulnerabilities: {
  //   "package-name": { "name": "package-name", "severity": "...", "via": [...], fixAvailable: ...  }
  // }
  // The 'via' array often contains the actual advisory details or a source ID to link to a separate 'advisories' object.
  // Let's assume a structure where vulnerabilities contains the core info and links to advisories by ID.
}


/**
 * Scans Node.js project dependencies using `npm audit --json`.
 * This function assumes that the project uses npm and has a package-lock.json.
 *
 * @param projectPath The absolute path to the Node.js project directory.
 * @param dependencies (Optional) The list of dependencies. npm audit works on the lockfile directly.
 * @returns A Promise that resolves to an array of Vulnerability objects.
 */
export async function scanNpmAudit(projectPath: string, dependencies?: Dependency[]): Promise<Vulnerability[]> {
  const foundVulnerabilities: Vulnerability[] = [];
  const packageLockPath = joinPath(projectPath, 'package-lock.json');

  if (!(await pathExists(packageLockPath))) {
    console.warn(`Skipping npm audit scan: package-lock.json not found in ${projectPath}`);
    return [];
  }

  // `npm audit --json` can be slow. Consider a timeout.
  // The command should be run in the project directory.
  const command = 'npm audit --json';
  const result: CommandResult = await executeCommand(command, { cwd: projectPath });

  if (result.stderr && result.exitCode !== 0 && !result.stdout) { // npm audit might exit > 0 if vulns found
    // Check if stderr indicates a real execution error vs. just audit findings
    // Some npm versions output to stderr even on successful audit with findings
    if (!result.stderr.toLowerCase().includes('found vulnerabilities')) {
        console.error(`npm audit command execution failed for ${projectPath}: ${result.stderr}. Exit code: ${result.exitCode}`);
        // return []; // or throw
    }
  }
  
  if (!result.stdout) {
    console.warn(`npm audit produced no stdout for ${projectPath}. Stderr: ${result.stderr}`);
    return [];
  }

  try {
    const auditOutput = JSON.parse(result.stdout) as NpmAuditOutput;

    // The structure of `npm audit --json` can vary slightly across npm versions.
    // We need to adapt to the common patterns.
    // Modern npm often has a top-level 'vulnerabilities' object.
    // Older versions might have 'advisories' and findings that refer to these advisories.

    if (auditOutput.vulnerabilities) {
      for (const vulnKey in auditOutput.vulnerabilities) {
        const auditVuln = auditOutput.vulnerabilities[vulnKey];
        
        // Extracting details can be complex due to 'via' array structure.
        // 'via' can contain strings (other packages) or objects with advisory details.
        let title = `Vulnerability in ${auditVuln.name}`;
        let description = `Package ${auditVuln.name} is affected by a vulnerability. Affected versions: ${auditVuln.range}.`;
        let advisoryUrl = '';
        let cveIdFromVia: string | undefined = undefined;
        let cvssFromAdvisory: CVSS | undefined = undefined;
        let patchedVersionsFromAdvisory : string | undefined = undefined;
        let vulnerableVersionsFromAdvisory : string | undefined = auditVuln.range;


        // Try to get more details from the 'via' array if it contains advisory objects
        // or from a separate 'advisories' object if linked by ID.
        // This parsing logic needs to be robust.
        if (Array.isArray(auditVuln.via)) {
            for (const viaEntry of auditVuln.via) {
                if (typeof viaEntry === 'object' && viaEntry !== null && viaEntry.url && viaEntry.title) {
                    title = viaEntry.title || title;
                    advisoryUrl = viaEntry.url || advisoryUrl;
                    // Attempt to extract CVE from URL or title if possible (heuristic)
                    const cveMatch = advisoryUrl.match(/(CVE-\d{4}-\d{4,})/i) || title.match(/(CVE-\d{4}-\d{4,})/i);
                    if (cveMatch && cveMatch[1]) {
                        cveIdFromVia = cveMatch[1];
                    }
                    // If `npm audit` provides CVSS directly in advisory objects (some versions do)
                    if (auditOutput.advisories && viaEntry.source && auditOutput.advisories[viaEntry.source.toString()]) {
                        const advisory = auditOutput.advisories[viaEntry.source.toString()];
                        if(advisory.cvss && advisory.cvss.score){
                            cvssFromAdvisory = {
                                score: advisory.cvss.score,
                                vectorString: advisory.cvss.vectorString || 'N/A',
                                version: '3.1' // Assuming CVSSv3, npm audit might not always specify
                            };
                        }
                        patchedVersionsFromAdvisory = advisory.patched_versions;
                        vulnerableVersionsFromAdvisory = advisory.vulnerable_versions;

                    }
                    break; // Take details from the first rich advisory object in 'via'
                }
            }
        }
        
        const vulnId = cveIdFromVia || (auditVuln.via && auditVuln.via.find(v => typeof v === 'object' && v.source) ? `NPM-${(auditVuln.via.find(v => typeof v === 'object' && v.source) as any).source}` : `NPM-AUDIT-${auditVuln.name}-${auditVuln.range}`);
        const fixInfo = auditVuln.fixAvailable;
        const fixedVersions: string[] = [];
        if (typeof fixInfo === 'object' && fixInfo !== null && fixInfo.name === auditVuln.name && fixInfo.version) {
            fixedVersions.push(fixInfo.version);
        } else if (patchedVersionsFromAdvisory && patchedVersionsFromAdvisory !== "<0.0.0") { // "<0.0.0" means no patch
            fixedVersions.push(patchedVersionsFromAdvisory);
        }


        foundVulnerabilities.push({
          id: vulnId,
          packageName: auditVuln.name,
          // npm audit output directly gives affected package, not the specific installed version easily without more parsing
          // We need to map this back to the Dependency list or assume it applies to versions within `auditVuln.range`
          // For now, let's use the range as affected.
          packageVersion: auditVuln.range, // This is the vulnerable *range*, not the installed version.
          title: title,
          description: description,
          severity: auditVuln.severity.toUpperCase() as Vulnerability['severity'],
          cvss: cvssFromAdvisory, // This may or may not be present or accurate
          affectedVersions: vulnerableVersionsFromAdvisory ? [vulnerableVersionsFromAdvisory] : [auditVuln.range],
          fixedVersions: fixedVersions.length > 0 ? fixedVersions : undefined,
          references: advisoryUrl ? [{ url: advisoryUrl }] : [],
        });
      }
    } else if (auditOutput.advisories) {
        // Handle older npm audit format if necessary (where advisories are flat and actions/findings link to them)
        // This would require more complex logic to map findings back to dependencies.
        console.warn("`npm audit --json` output has 'advisories' top-level key. Parsing this format is more complex and not fully implemented in this example.");
    }


  } catch (error) {
    console.error(`Error parsing npm audit JSON output for ${projectPath}: ${error instanceof Error ? error.message : String(error)}. Raw output: ${result.stdout.substring(0, 500)}...`);
  }

  return foundVulnerabilities;
}

// Later, you might add scanYarnAudit if a project is identified as using Yarn + yarn.lock
// export async function scanYarnAudit(projectPath: string, dependencies: Dependency[]): Promise<Vulnerability[]> { /* ... */ }
