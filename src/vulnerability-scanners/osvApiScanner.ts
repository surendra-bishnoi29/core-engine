// core-engine/src/vulnerability-scanners/osvApiScanner.ts

import * as https from 'https';
import { Dependency, Vulnerability, CVSS } from '../shared/types';

// OSV API specific types (simplified)
interface OsvQuery {
  version: string;
  package: {
    name: string;
    ecosystem: string; // e.g., "npm", "PyPI"
  };
}

interface OsvAffectedRange {
  type: 'SEMVER' | 'ECOSYSTEM' | string; // Typically SEMVER for npm
  repo?: string;
  events: Array<{ introduced?: string; fixed?: string; limit?: string }>;
}

interface OsvSeverity {
  type: string; // e.g., "CVSS_V3"
  score: string; // e.g., "9.8", "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
}

interface OsvReference {
  type: string; // e.g., "ADVISORY", "ARTICLE", "FIX"
  url: string;
}

interface OsvVulnerability {
  id: string; // OSV ID
  summary?: string;
  details?: string;
  aliases?: string[]; // e.g., CVE IDs
  modified: string;
  published: string;
  references?: OsvReference[];
  affected: Array<{
    package: {
      name: string;
      ecosystem: string;
      purl?: string;
    };
    ranges?: OsvAffectedRange[];
    versions?: string[];
  }>;
  severity?: OsvSeverity[];
  database_specific?: any; // Can contain CVSS vector etc.
}

interface OsvQueryResult {
  vulns?: OsvVulnerability[];
}

interface OsvBatchQuery {
  queries: OsvQuery[];
}

interface OsvBatchQueryResult {
  results: OsvQueryResult[];
}

const OSV_API_URL = 'api.osv.dev';
const OSV_BATCH_QUERY_PATH = '/v1/querybatch';

async function makeOsvApiRequest(
  payload: OsvBatchQuery
): Promise<OsvBatchQueryResult | null> {
  const postData = JSON.stringify(payload);

  const options: https.RequestOptions = {
    hostname: OSV_API_URL,
    path: OSV_BATCH_QUERY_PATH,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': Buffer.byteLength(postData),
    },
  };

  return new Promise((resolve) => {
    let responseBody = '';
    const req = https.request(options, (res) => {
      res.setEncoding('utf8');
      res.on('data', (chunk) => {
        responseBody += chunk;
      });
      res.on('end', () => {
        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
          try {
            resolve(JSON.parse(responseBody) as OsvBatchQueryResult);
          } catch (e) {
            console.error('OSV API: Error parsing JSON response:', e);
            resolve(null);
          }
        } else {
          console.error(
            `OSV API: Request failed with status code ${res.statusCode}: ${responseBody}`
          );
          resolve(null);
        }
      });
    });

    req.on('error', (e) => {
      console.error('OSV API: Problem with request:', e);
      resolve(null);
    });

    req.write(postData);
    req.end();
  });
}

function mapOsvToInternalVulnerability(
  osvVuln: OsvVulnerability,
  dep: Dependency // The dependency that this OSV vuln applies to
): Vulnerability {

  let severity: Vulnerability['severity'] = 'INFO'; // Default
  let cvss: CVSS | undefined = undefined;

  if (osvVuln.severity && osvVuln.severity.length > 0) {
    // Prioritize CVSS_V3, then look for score.
    // OSV severity score is a string like "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H" or just numeric score
    const cvssV3Severity = osvVuln.severity.find(s => s.type === 'CVSS_V3');
    if (cvssV3Severity) {
        // Try to parse out the numeric score and vector from the string
        const scoreMatch = cvssV3Severity.score.match(/(\d+\.\d+)/);
        const numericScore = scoreMatch ? parseFloat(scoreMatch[1]) : 0;

        cvss = {
            score: numericScore,
            vectorString: cvssV3Severity.score, // The full string is the vector
            version: '3.1' // Assuming 3.1 if type is CVSS_V3
        };
        if (numericScore >= 9.0) severity = 'CRITICAL';
        else if (numericScore >= 7.0) severity = 'HIGH';
        else if (numericScore >= 4.0) severity = 'MODERATE';
        else if (numericScore > 0.0) severity = 'LOW';
    }
    // Add more sophisticated severity parsing if needed
  }

  const affectedVersionsStrings: string[] = [];
  osvVuln.affected?.forEach(aff => {
    aff.versions?.forEach(v => affectedVersionsStrings.push(v));
    aff.ranges?.forEach(r => {
        r.events.forEach(e => {
            if(e.introduced === "0") { // Common way to say "all versions up to fixed"
                if(e.fixed) affectedVersionsStrings.push(`< ${e.fixed}`);
                else if (e.limit) affectedVersionsStrings.push(`< ${e.limit}`); // or <=
                else affectedVersionsStrings.push('(*)'); // All versions
            } else if (e.introduced) {
                if(e.fixed) affectedVersionsStrings.push(`>= ${e.introduced}, < ${e.fixed}`);
                else if (e.limit) affectedVersionsStrings.push(`>= ${e.introduced}, < ${e.limit}`);
                else affectedVersionsStrings.push(`>= ${e.introduced}`);
            }
        });
    });
  });


  // Try to find a fixed version from the ranges
  let fixedVersionFromRange: string | undefined;
  osvVuln.affected?.forEach(aff => {
    aff.ranges?.forEach(r => {
        const fixedEvent = r.events.find(e => e.fixed);
        if(fixedEvent && fixedEvent.fixed) {
            fixedVersionFromRange = fixedEvent.fixed;
        }
    });
  });


  return {
    id: osvVuln.id,
    packageName: dep.name,
    packageVersion: dep.version, // The specific version from the project
    title: osvVuln.summary || osvVuln.id,
    description: osvVuln.details || osvVuln.summary || 'No details provided.',
    severity,
    cvss,
    affectedVersions: affectedVersionsStrings.length > 0 ? affectedVersionsStrings : ['N/A'],
    fixedVersions: fixedVersionFromRange ? [fixedVersionFromRange] : undefined, // OSV may not always list a single "fixed" version easily
    references: osvVuln.references
      ? osvVuln.references.map((ref) => ({ url: ref.url, type: ref.type }))
      : [],
  };
}

/**
 * Scans a list of dependencies using the OSV.dev batch API.
 * @param dependencies The list of Dependency objects to scan.
 * @returns A Promise that resolves to an array of Vulnerability objects.
 */
export async function scanOsvApi(
  dependencies: Dependency[]
): Promise<Vulnerability[]> {
  if (!dependencies || dependencies.length === 0) {
    return [];
  }

  const queries: OsvQuery[] = dependencies.map((dep) => ({
    version: dep.version,
    package: {
      name: dep.name,
      // Map internal ecosystem name to OSV ecosystem string
      ecosystem: dep.ecosystem === 'npm' || dep.ecosystem === 'yarn' ? 'npm' : dep.ecosystem,
    },
  }));

  const batchQueryPayload: OsvBatchQuery = { queries };
  const apiResult = await makeOsvApiRequest(batchQueryPayload);

  const foundVulnerabilities: Vulnerability[] = [];

  if (apiResult && apiResult.results) {
    apiResult.results.forEach((queryResult, index) => {
      if (queryResult.vulns && queryResult.vulns.length > 0) {
        const originalDependency = dependencies[index]; // Relies on order being preserved
        queryResult.vulns.forEach((osvVuln) => {
          foundVulnerabilities.push(
            mapOsvToInternalVulnerability(osvVuln, originalDependency)
          );
        });
      }
    });
  }

  return foundVulnerabilities;
}